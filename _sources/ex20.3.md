

### Replace the Springs of the Double-Pendulum by Distance Constraints
In the original 3D mass–spring example, the double pendulum is modeled using two springs:  
- one connecting the fixed point to the first mass,  
- one connecting the first mass to the second mass.  

In this task, we remove the springs entirely and replace them with **holonomic distance constraints** enforcing:

\[
\|x_i - x_j\| = L_0.
\]

This converts the system from a soft spring model into a rigid “rod-like” double pendulum where the distances remain constant throughout the simulation.




1. Remove the springs

The original example contained:
```python
mss.add(Spring(1, 200000, (f1, mA)))
mss.add(Spring(1, 100000, (mA, mB)))
```
These are completely removed.

2. To avoid external forces at initialization, the rest-lengths are computed directly from the initial distances:
```python
def distance(p, q):
    return ((p[0]-q[0])**2 +
            (p[1]-q[1])**2 +
            (p[2]-q[2])**2 )**0.5

L1 = distance(mss.fixes[f1.nr].pos, mss.masses[mA.nr].pos)
L2 = distance(mss.masses[mA.nr].pos, mss.masses[mB.nr].pos)
```
3. Add distance constraints

Using `DistanceConstraint` springs are removed and replaced by fixed-length distance constraints.


```python
dc1 = DistanceConstraint(f1, mA, L1)
mss.addDistanceConstraint(dc1)

dc2 = DistanceConstraint(mA, mB, L2)
mss.addDistanceConstraint(dc2)
```
4. Constraint segments are drawn the same way as springs, but stay at a fixed length:
```python
springpos = []
for c in mss.constraints:
    pA = mss.fixes[c.c1.nr].pos if c.c1.type == 1 else mss.masses[c.c1.nr].pos
    pB = mss.fixes[c.c2.nr].pos if c.c2.type == 1 else mss.masses[c.c2.nr].pos
    springpos.append([pA, pB])

springs.geometry = LineSegmentsGeometry(positions=springpos)
```

The double pendulum behaves like a rigid two-link system with no stretching or compression.