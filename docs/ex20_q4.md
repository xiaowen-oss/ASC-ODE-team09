## Q4: 3D Version: Experiment with different mechanical structures

### Model 1 : Extend the double-pendulum to a chain

*Complete code -- chian with springs is in 'chain_spring.ipynb'*

*Complete code -- chain with constraints is in 'chain_constraint.ipynb'*

### Chain with spring

Assume the quantity of each mass: 1, length of the spring:1, the spring constant:1000, still fixed point at the origin.

We only need to change the geometry part. Here we write a `for` loop to add more masses and springs:

```
#create for loop
for i in range(N_MASSES):
    
    initial_pos = (SPRING_LENGTH * (i + 1), 0.0, 0.0)
    
    # add new mass
    current_mass_connector = mss.add(Mass(MASS_VAL, initial_pos)) 
    
    # add new spring
    mss.add(Spring(SPRING_LENGTH, 
                   SPRING_STIFFNESS, 
                   (previous_connector, current_mass_connector)))
    
    # refresh
    previous_connector = current_mass_connector

```

Such that everytime, we only need to change `N_MASSES`


**Test 1**: When mass = 5

<video width="600" controls>
  <source src="_static/chain_spring5.mp4" type="video/mp4">
</video>


**Test 2**: When mass = 10

<video width="600" controls>
  <source src="_static/chain_spring10.mp4" type="video/mp4">
</video>

---

### Chain with constaint

Similarly, we write a `for` loop to add mass and constraint.

```
for i in range(N_MASSES):
    initial_pos = (LINK_LENGTH * (i + 1), 0.0, 0.0)
    
    # add new mass
    current_mass_connector = mss.add(Mass(1, initial_pos)) 
    
    # add new constraint and connet it to the previous mass
    dc = DistanceConstraint(previous_connector, current_mass_connector, LINK_LENGTH)
    mss.addDistanceConstraint(dc)
    
    # refresh
    previous_connector = current_mass_connector

```

Such that everytime, we only need to change `N_MASSES`

```
N_MASSES = 5
LINK_LENGTH = 1.0
```

**Test 1**: When mass = 5

<video width="600" controls>
  <source src="_static/chain.mp4" type="video/mp4">
</video>


**Test 2**: When mass = 10

<video width="600" controls>
  <source src="_static/chain10.mp4" type="video/mp4">
</video>

Reuslt: 
- With larger masses, the system begins to approximate a continuous body (such as a soft rope or a whip).

- The end mass resembling the tip of a whip, characterized by the propagation of waves and accelerated whipping motion.

- The hole system will turn slow, bulk oscillation, and faster, small-scale localized twisting and vibrational patterns emerging throughout the chain.

---
### Model 2 : 



---
### Model 3 : Replace the Springs of the Double-Pendulum by Distance Constraints
In the original 3D mass–spring example, the double pendulum is modeled using two springs:  
- one connecting the fixed point to the first mass,  
- one connecting the first mass to the second mass.  

In this task, we remove the springs entirely and replace them with **holonomic distance constraints** enforcing:

$$
\|x_i - x_j\| = L_0.
$$

This converts the system from a soft spring model into a rigid “rod-like” double pendulum where the distances remain constant throughout the simulation.


1. Remove the springs

The original example contained:
```python
mss.add(Spring(1, 200000, (f1, mA)))
mss.add(Spring(1, 100000, (mA, mB)))
```
These are completely removed.

2. To avoid external forces at initialization, the rest-lengths are computed directly from the initial distances:
```python
def distance(p, q):
    return ((p[0]-q[0])**2 +
            (p[1]-q[1])**2 +
            (p[2]-q[2])**2 )**0.5

L1 = distance(mss.fixes[f1.nr].pos, mss.masses[mA.nr].pos)
L2 = distance(mss.masses[mA.nr].pos, mss.masses[mB.nr].pos)
```
3. Add distance constraints

Using `DistanceConstraint` springs are removed and replaced by fixed-length distance constraints.


```python
dc1 = DistanceConstraint(f1, mA, L1)
mss.addDistanceConstraint(dc1)

dc2 = DistanceConstraint(mA, mB, L2)
mss.addDistanceConstraint(dc2)
```
4. Constraint segments are drawn the same way as springs, but stay at a fixed length:


```python
springpos = []
for c in mss.constraints:
    pA = mss.fixes[c.c1.nr].pos if c.c1.type == 1 else mss.masses[c.c1.nr].pos
    pB = mss.fixes[c.c2.nr].pos if c.c2.type == 1 else mss.masses[c.c2.nr].pos
    springpos.append([pA, pB])

springs.geometry = LineSegmentsGeometry(positions=springpos)
```

3. When the Lagrange multiplier becomes very large, the Jacobian matrix used in the Newton solver becomes numerically ill-conditioned.

Error **Newton did not converge** exist.

We increase the tolerance and max. iteration to *1e-9* and *20*. And slow down the video *sleep(0.3)*

Finally we get:

<video width="600" controls>
  <source src="_static/ms_la_con.mp4" type="video/mp4">
</video>


Obviously, the constraint connection lines maintain a fixed length, regardless of how the mass blocks move. The segments do not stretch or contract noticeably like a soft spring, making the connections appear as metal rods.

---
### Model 4 : 


